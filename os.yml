-
  - 교착 상태가 무엇이고, 이게 발생되려면 어떤 조건이 필요하죠?
  - |
    '교착 상태'란 두 개 이상의 스레드 또는 프로세스가 각자의 자원을 요구하는 상황

    이러한 상태가 발생되기 위해서는 아래의 네 가지 조건이 모두 성립해야 가능함

    * 각 자원은 하나의 스레드 또는 프로세스만이 차지할 수 있다
    * 각 자원을 강제로 회수할 수는 없다
    * 각 스레드 또는 프로세스는 자신에게 필요한 자원을 차지중이다
    * 양쪽의 스레드 또는 프로세스는 서로가 필요한 자원을 차지중이다

    교착 상태를 해결하기 위해서는 위의 조건 중 하나라도 성립하지 않도록 하면 됨

    ![pic](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/fbd42847-a1f9-4b3f-b4df-7f5f8f04859f/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20200905%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20200905T043320Z&X-Amz-Expires=86400&X-Amz-Signature=7c84fa937f9e110ec15e0f067cca87ba073d6373197cbc04adb7135a301511b2&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

    이건 그냥 어렵게 생각하지 말고, 4개의 조건이 있으며 A와 B가 자신의 자원을 차지중이고 서로의 자원까지 요구하는 그런 상황을 생각해보자

-
  - 메모리 계층을 설명해보세요
  - 레지스터, 캐시, 메모리, 하드디스크 순서로 계층이 이루어져 있음

-
  - 메모리 할당 알고리즘 중 First fit, Next fit, Best fit의 결과를 말해보세요
  - |
    * First fit: 메모리의 처음부터 탐색하며 크기가 충분한 공간이 있을 경우 할당
    * Next fit: 마지막으로 참조한 주소부터 탐색을 시작하며 크기가 충분한 공간이 있을 경우 할당
    * Best fit: 모든 메모리 공간을 검사하는것은 동일하나, 단편화를 최소화시킬 수 있는 공간에 할당하는 방식

-
  - 페이지 교체 알고리즘에 따른 Page Fault 방식을 설명해보세요
  - |
    # Page Fault가 무엇이냐

    프로세스가 어떤 특정 페이지를 요구하는 경우, 이를 메모리에서 가져와 사용해야 함

    이 때 필요로 하는 페이지가 메모리에 없는 경우를 Page Fault라고 하며, HDD와 같은 외부 저장 공간에서 페이지를 가져와

    메모리 내 빈 프레임이나 기존의 프레임을 교체하는 방식으로 메모리에 적재해 사용함

    다만... 빈 프레임은 그냥 적재하면 되는데, 기존의 프레임을 교체하는 경우에는 주의를 기울여야 함

    활발히 사용중인 페이지의 프레임을 교체해버린 경우에는 이를 다시 불러오기 위한 작업이 필요하기에 그만큼의 오버헤드가 발생되기 때문

    따라서 이를 위한 여러 알고리즘이 존재

    # Page Fault Algorithms

    ### FIFO (First In First Out)

    먼저 First In First Out 알고리즘이 있음

    가장 오래된 페이지를 교체하는 방식으로, 구현이 가장 간단하지만 상당히 비효율적인 알고리즘

    ### LRU (Last Recently Used)

    다음으로 가장 오래 사용되지 않은 페이지를 교체하는 알고리즘인 Last Recently Used 알고리즘이 있음

    교체 전까지 각 페이지가 참조되지 않은지 얼마나 지났는지를 확인하여 교체하는 방식으로

    상당히 효율적으로 동작하기에 여러 OS에서 채택하여 사용중

    ### LFU (Last Frequently Used)

    가장 적게 참조된 페이지를 교체하는 Last Frequently Used 알고리즘이란것도 있는데

    여기에는 약간의 이슈가 존재하여 잘 사용되지는 않음

    초반에 하나의 페이지를 집중적으로 사용하고, 이후 해당 페이지를 사용하지 않는다면

    교체되기 전까지 해당 프레임을 사용할 수 없게 된다는 이슈가 있기에 잘 사용되지는 않음

-
  - 가상 메모리가 무엇인가요
  - |
    물리적인 실제 메모리보다 더 많은 메모리를 필요로 하는 경우가 종종 있음

    이 경우 하드디스크와 같이 외부의 저장 공간을 이용하여 현재 메모리 내에서 사용되지 않는 데이터를 캐싱하는 방식으로

    마치 추가적인 메모리를 사용하는 것과 같이 동작하게 할 수 있는데

    이 때 이 외부의 저장 공간을 가상 메모리라고 함

-
  - 페이징과 프레임, 그리고 세그멘테이션이라는 단어를 들어보셨나요?
  - |
    # 페이징이란

    프로세스를 일정한 크기인 Page로 잘라 메모리에 적재하는 기법임

    page 단위로 프로세스를 잘라 관리하기에 단편화를 최대한 제거할 수 있음

    물론 마지막 page의 경우 약간의 내부 단편화가 발생하기는 하는데, 이는 기존 방법으로 인해 생겼던 외부 단편화보다는 매우 미미한 수준

    이는 메모리에서 가상 주소와 실제 주소를 매핑해주는 Memory Management Unit이라는 장치를 이용해 가능한데

    잘라진 page를 마치 연결된 것처럼 주소를 연결시켜서 CPU를 속이는 방식으로 페이징을 진행

    # 프레임

    페이징과 비슷한 기법인 프레임은, 프로세스가 아닌 메모리를 frame 단위로 잘라 관리하는 기법

    page와 frame을 같은 크기로 잘라 관리하게 되면 상당히 메모리 관리에 있어 편리하게 되겠지

    # 세그멘테이션

    세그멘테이션은 page와 비슷한데, page는 그냥 크기 단위로 프로세스를 잘랐지만 segment의 경우 논리적인 단위로 프로세스를 자르는 기법임

    가령... function은 function대로, class는 class대로 나누듯이 말이지

    이 덕분에 중요한 부분은 따로 관리할 수 있게 됨

    단, 크기는 동일하지 않기에 외부 단편화가 일어날 수 있음

    ## 세그먼트 페이징

    그래서 segment paging 이라는 기법을 이용하곤 하는데
    
    이건 논리적 단위로 자른 segment를 page 단위로 페이징하는 기법

    이 덕분에 세그멘테이션에서 나타났던 외부 단편화 문제를 해결할 수 있으나...

    물론 속도 측면에서는 좋지 못하다는게 단점

-
  - Mutex, Semaphore. 이 둘은 무엇이고, 둘의 차이점은?
  - |
    이 둘은 여러개의 프로세스나 스레드 사이에서 공유되는 자원에 대해 접근을 제한하기 위한 알고리즘

    # Semaphore

    먼저 Semaphore는 두 개 이상의 스레드나 프로세스에 대해 접근을 제한하는 알고리즘이며

    최대 수용치를 정해놓은 다음, 접근 시마다 하나씩 카운트를 줄여가는 방식으로 접근을 제한함

    # Mutex

    Mutex는 하나의 공유 자원에는 최대 하나의 프로세스나 스레드만이 접근할 수 있도록 상호배제적으로 접근을 제한하는 알고리즘

    이러한 특성으로 Semaphore는 Mutex로도 사용이 가능하지만, Mutex는 Semaphore로 사용이 불가능함

-
  - Context Switching은 무엇인가요
  - |
    concurrent system에서 주로 볼 수 있는 기법임

    프로세스에 대한 context switching을 예로 들어보자면

    CPU는 여러개의 프로세스가 잠깐잠깐씩 나누어서 사용해야 하는데

    이 때, 다른 프로세스로 switching하기 전에 현재 CPU를 사용하고 있는 프로세스의 정보를 Kernel의 Process Control Block이라는 자료구조로 저장하고

    그 이후에 다른 프로세스로 CPU 사용 권한을 넘기는 그런 작업이 바로 Context Switching임

    다시 원래 프로세스로 switching 할 때는 이 PCB에 기록된 정보를 이용해서 작업하게 됨

-
  - user level thread와 kernel level thread의 차이는 무엇인가?
  - |
    # user level thread

    먼저 user level thread의 경우

    라이브러리를 이용해 kernel level thread에서 fork되는 방식으로 만들어짐

    kernel level에서 구현된 것이 아니기에 스케줄링이나 동기화에 있어 library-level에서 관리가 가능하며, 이로 인한 오버헤드가 상대적으로 적다는 특징이 있음

    단, 마찬가지로 kernel level의 스레드가 아니기에 하나의 스레드가 정지된다면 다른 스레드 역시 영향을 받아 정지된다는 단점이 있음

    # kernel level thread

    다음으로 kernel level thread의 경우

    kernel에 요청해서 직접 스레드를 할당받아 사용하는 형태로 만들어지기에, 자원 면에서 있어 상대적으로 풍부하게 사용이 가능하고

    concurrent가 아닌 parallel 방식으로 스레드를 사용할 수가 있어 하나의 스레드가 멈추더라도 다른 스레드에는 영향을 끼치지 않는다는 특징이 있음

    다만, user level thread와는 달리 kernel level에서 thread context switching이 진행되기에, 이에 따른 system-call로 인한 오버헤드가 상대적으로 크다는 단점이 있음

-
  - Race Condition이란 무엇인가요
  - |
    두 개 이상의 프로세스가 공유 자원에 서로 접근하는 경우에 발생될 수 있음

    접근 순서에 따라 결과가 달라지는 것을 의미하는데

    다시말해 side-effects가 발생된다고 할 수 있겠으며

    이는 어떠한 동작에 대해 원하는 결과가 보장된다고 할 수 없기에

    mutex나 semaphore를 통해 적절한 제한을 취해주어야만 함

-
  - 프로세스와 스레드의 차이를 말씀해주세요
  - |
    # 프로세스

    프로세스는 코드가 메모리상에 적재되어 CPU를 통해 실행되는 상태를 의미

    따라서 프로그램별로 하나의 프로세스를 가짐

    # 스레드

    스레드는 하나의 프로세스 내에서 시분할 방식으로 작업을 처리할 수 있도록 하는 기법

    하나의 프로세스 내에 여러개의 스레드를 가질 수 있으며, user level thread와 kernel level thread가 있다

    # 저장 공간

    프로세스별로 각각의 stack, heap, code, data 공간을 메모리에 할당받으며

    스레드는 이 중 stack만을 별도로 가지고, 나머지 공간은 공유하는 방식으로 동작한다

-
  - 멀티 프로세스 대신 멀티 스레드를 사용하는 이유는 무엇일까요?
  - |
    # 멀티 프로세스

    여러개의 프로세스를 생성하게 되면 프로세스별로 stack, heap, code, data 공간이 따로 할당되어야 하기에 공간적으로 비효율적이며

    프로세스간 통신을 위해서도 IPC BUS를 이용해야 하기에 시간적으로도 비효율적이다

    # 멀티 스레딩

    stack만을 별도로 사용하고, 나머지 메모리 공간은 공유하기에 시간적으로나 공간적으로나 멀티 프로세스 방식보다 효율적

    다만 user level thread의 경우, 하나의 스레드가 멈추었을 경우 다른 스레드 또한 사용이 불가능하다는 단점이 있고

    공유하는 메모리 공간 또한 Mutex나 Semaphore와 같은 기법을 이용해 동기화를 신경써줘야만 한다
