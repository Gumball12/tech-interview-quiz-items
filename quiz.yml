-
  - 프로세스와 스레드의 차이를 말씀해주세요
  - |
    # 프로세스

    프로세스는 코드가 메모리상에 적재되어 CPU를 통해 실행되는 상태를 의미

    따라서 프로그램별로 하나의 프로세스를 가짐

    # 스레드

    스레드는 하나의 프로세스 내에서 시분할 방식으로 작업을 처리할 수 있도록 하는 기법

    하나의 프로세스 내에 여러개의 스레드를 가질 수 있으며, user level thread와 kernel level thread가 있다

    # 저장 공간

    프로세스별로 각각의 stack, heap, code, data 공간을 메모리에 할당받으며

    스레드는 이 중 stack만을 별도로 가지고, 나머지 공간은 공유하는 방식으로 동작한다

-
  - 멀티 프로세스 대신 멀티 스레드를 사용하는 이유는 무엇일까요?
  - |
    # 멀티 프로세스

    여러개의 프로세스를 생성하게 되면 프로세스별로 stack, heap, code, data 공간이 따로 할당되어야 하기에 공간적으로 비효율적이며

    프로세스간 통신을 위해서도 IPC BUS를 이용해야 하기에 시간적으로도 비효율적이다

    # 멀티 스레딩

    stack만을 별도로 사용하고, 나머지 메모리 공간은 공유하기에 시간적으로나 공간적으로나 멀티 프로세스 방식보다 효율적

    다만 user level thread의 경우, 하나의 스레드가 멈추었을 경우 다른 스레드 또한 사용이 불가능하다는 단점이 있고

    공유하는 메모리 공간 또한 Mutex나 Semaphore와 같은 기법을 이용해 동기화를 신경써줘야만 한다

-
  - 가비지 컬렉션이란?
  - |
    현재 참조되지 않는 객체를 메모리에서 제거하는 메모리 관리 기법

    기본적으로 모든 객체를 순회하며 제거하기만, 효율을 위해 이것보다 성능적으로 개선된 알고리즘이 있다

    # Generation GC

    생성되지 얼마 되지 않은 객체는 얼마 가지 않아 사용되지 않는다는 경향을 바탕으로 구현된 GC

    Young Generation과 Old Generation 그리고 Metasapce로 구성되어 있으며
    
    Young Generation은 생성되지 얼마 되지 않은 객체를

    Old Generation은 생성된 후 일정 시간이 지난 이후의 객체를

    Metaspace는 Class 및 Method의 metadata를 보관하는 공간을 의미

    # 동작

    Generation GC의 동작은 다음과 같다

    1. 방금 생성된 객체는 Young Generation으로 이동
    2. 이후 Garbage Collection을 진행하며 각 객체에 age를 매기고
    3. 일정 수치의 age가 넘어간 객체는 Old Generation으로 이동시켜 관리

    이를 통해 모든 객체를 순회하지 않고, 일부 객체에 대해서만 GC를 진행할 수 있도록 알고리즘의 구현이 가능하게 됨

    즉, 기존의 방법보다 효율적인 GC의 구현이 가능하게 됨

-
  - Vector와 ArrayList의 차이를 말해보세요
  - |
    # Vector

    Vector는 동기식으로 동작함

    다시말해, 하나의 스레드가 어떤 vector 객체에서 작업중이라면

    다른 스레드는 해당 vector 객체에 접근할 수 없다는 것을 의미함

    # ArrayList

    ArrayList는 이와는 달리 비동기식으로 동작함

    하나의 스레드가 어떤 ArrayList 객체에서 작업중이어도

    다른 스레드 역시 해당 ArrayList 객체에 접근할 수 있다는 것을 의미함

-
  - String과 StringBuffer의 차이를 말해보세요
  - |
    # String

    `String` 객체는 immutable

    즉, 기존의 `String`을 수정한다면 새로운 `String` 객체를 생성해야 한다는 것을 의미

    # StringBuffer

    `StringBuffer` 객체는 mutable하다

    기존의 객체를 이용해 수정이 가능하며, 이것이 `String`과의 차이

-
  - Serialization이란?
  - |
    객체의 상태를 기록할 수 있도록 어떠한 포맷으로 변환하는 작업을 의미함

    가령 js의 `JSON.stringify()`와 `JSON.parse()`를 예로 들 수 있는데

    이를 이용해 객체의 특정한 상태를 저장할 수 있다

-
  - Java의 메모리 영역을 설명해보세요
  - |
    Java의 메모리 영역은 Heap, Stack, Method 세 가지로 구분됨

    * Method: Bytecode, Global variables, Static variables
    * Stack: Arguments, Local variables
    * Heap: Instances

-
  - Overload와 Override의 차이는 무엇인가요?
  - |
    # Overload는

    메서드의 이름만 같고... 파라미터의 타입, 개수, 순서 셋 중 하나 이상이 다른 메서드
    
    이를 이용해 파라미터의 종류에 따라 다른 동작을 하도록 메서드를 구현할 수 있음

    # Override는

    메서드의 이름과 파라미터의 타입, 개수, 순서 그리고 반환 타입까지 모두 같은 메서드

    즉, Override는 '재정의'를 하는 것이라고 할 수 있음

-
  - Abstract class와 Interface의 차이
  - |
    # 추상클래스의 경우

    일부 메서드가 abstract method로 구현이 되어 있으며

    이를 하위 클래스에서 `extends` 키워드를 통해 확장받는 방식으로 구현함

    # Interface의 경우

    모든 메서드가 abstract method로 구현이 되어 있으며

    이를 하위 클래스에서 `implements` 키워드를 통해 구현해야 하고

    여러개의 interface의 구현이 가능함

-
  - Generic이란 무엇인가요?
  - |
    Type을 클래스 또는 메서드 구현 시에 정의하는 것이 아니라

    해당 class나 method를 사용할 때 정의하는 방식으로 타입을 정의하는 기법

    여기서 Generic type은 class, array와 같은 참조 자료형이나 Wrapper 클래스로 감싸진 기본 자료형이 될 수 있음

-
  - 접근 지정자를 설명해보세요
  - |
    접근 지정자는 `public`, `private`, `default`, `protected` 4개가 있으며, 각각 다음과 같음

    * `public`: 클래스 및 패키지 어느 곳에서든지 접근이 가능
    * `private`: 해당 클래스 내부에서만 접근이 가능
    * `default`: 같은 패키지 내부에서만 접근이 가능
    * `protected`: 같은 패키지 또는 상속받는 자식 클래스에서만 접근이 가능

-
  - Call by Reference와 Call by Value의 차이는 무엇이죠?
  - |
    # Call by Value는

    실제 Byte 값을 전달하는 것

    Stack에 존재하는 값을 복사하여 전달하는 것이기에, 원본의 값은 변하지 않는다는 특징이 있음

    # Call by Reference는

    메모리 Heap 영역에 위치한 주소값을 전달하는 것

    Byte 값을 전달하는 것은 동일하나, 이 값은 참조하는 객체의 주소값이기 때문에

    이를 이용하여 참조하는 객체의 값을 변경할 시 원본 객체의 값도 변경된다는 특징이 있음

-
  - Array와 Linked List의 차이는 무엇인가요
  - |
    # Array는

    시작 주소부터 순차적으로 데이터 타입의 크기 단위로 공간을 차지하기에

    정의한 이후에는 크기의 변경이 불가능함

    # Linked List는

    노드 단위로 이루어져 있으며, 노드에는 앞과 뒤 노드를 가리키는 포인터가 존재함

    포인터를 이용해 각각의 노드를 참조하기에 크기의 변경이 가능하고
    
    중간에 elements를 추가하거나 삭제할 때에도 속도가 빠르지만

    인덱스를 이용해 참조하는 경우에는 포인터를 통해 해당 노드까지 타고 들어가야 하니 Array보다 느린 속도를 보임

-
  - Hash란 무엇인가요?
  - |
    좀 더 효율적인 객체의 참조를 위해

    실제 객체가 아니라 객체 단위로 서로 겹치지 않는, 객체와 연관된 값을 부여한 뒤

    이를 이용해 객체를 참조하도록 하는 기법

-
  - Java 컴파일 과정을 설명해보세요
  - |
    1. Java 컴파일러를 통해 Source code를 Bytecode로 변환
    1. 이후 Bytecode를 실제 명령어로 변환하는 작업을 하는데, 이 작업은 JVM에서 처리하게 됨

    이전에는 JVM이 bytecode 실행 시마다 interpret하여 명령을 실행하는 방식을 이용했으나

    이후 JIT 컴파일러를 이용해 실제 실행할 때 interpret하고, 이후 해당 명령을 재사용하는 기법을 이용하여 좀 더 효율적으로 컴파일을 진행함

    이 JVM이 Bytecode를 CPU에 알맞은 명령어로 알아서 변환해주기에, 하나의 소스 코드로 다양한 시스템에서 동작할 수 있게 됨

-
  - CPP 실행 과정을 설명해보세요
  - |
    네 가지 과정을 거쳐 코드가 실행되게 됨

    1. preprocess: `#include`와 같은 지시자를 해석하게 됨
    1. compile: 코드를 asm으로 컴파일링하게 됨
    1. assemble: asm을 obj 파일, 즉 기계어로 번역하게 됨
    1. linking: 참조되는 다른 obj 파일이나 라이브러리를 엮어 execute 파일로 만듦

    linking 과정까지 끝마쳤으면 실제로 컴퓨터에서 실행할 수 있는 파일이 나오며, 이를 실행하여 코드가 실행되게 됨

-
  - 메모리 성능을 개선하기 위해서는 어떤 방법이 좋을까요?
  - |
    먼저 코드상으로 메모리 누수가 되는 부분이 있는지 확인함

    다음으로, 클래스의 instance는 꼭 필요한 경우에만 사용하고, 그렇지 않은 경우에는 `static`으로 선언하여 사용하도록 함

    인스턴스가 필요한 경우에도 얼마나 인스턴스가 필요한지 생각해볼 수 있겠는데, 가령 하나의 인스턴스만 필요하다면 singleton pattern을 이용해 하나의 인스턴스만을 이용하도록 구현할 수 있을 것임

-
  - class와 structure의 차이는 무엇인가요?
  - |
    둘 다 field를 갖는 것은 동일하나,

    구조체의 경우에는 다른 데이터 타입을 하나의 데이터 타입으로 묶어서 사용하도록 한 것이고

    클래스는 데이터 타입뿐만 아니라 메서드까지 묶어서 하나의 데이터 타입으로 묶어서 사용할 수 있도록 한 것의 차이를 가짐

    물론 구조체 역시 pointer를 이용해 함수를 가리키도록 할 수 있으나, 이건 메서드가 아니라 그냥 함수일 뿐임

-
  - thread는 어떤 방식으로 생성하나요? 그리고 장단점이 있을까요?
  - |
    user level thread의 경우 kernel level thread에서 fork하는 방식으로 스레드를 생성함

    스레드를 사용하면 병렬(parallel)까지는 아니지만 동시(concurrent)에 여러 작업을 처리할 수 있다는 장점이 있으나

    하나의 스레드가 멈춘다면 다른 스레드 또한 영향을 받아 멈춘다는 단점이 있음

-
  - pointer를 설명해보세요
  - |
    메모리상의 어떠한 위치를 가리키는 주소값임

    가령 집을 예로 들어보자면, 집마다 호수가 있고 호수를 통해 집을 특정할 수 있는데

    이 때 집의 호수가 pointer라고 할 수 있겠음

-
  - 교착 상태가 무엇이고, 이게 발생되려면 어떤 조건이 필요하죠?
  - |
    '교착 상태'란 두 개 이상의 스레드 또는 프로세스가 각자의 자원을 요구하는 상황

    이러한 상태가 발생되기 위해서는 아래의 네 가지 조건이 모두 성립해야 가능함

    * 각 자원은 하나의 스레드 또는 프로세스만이 차지할 수 있다
    * 각 자원을 강제로 회수할 수는 없다
    * 각 스레드 또는 프로세스는 자신에게 필요한 자원을 차지중이다
    * 양쪽의 스레드 또는 프로세스는 서로가 필요한 자원을 차지중이다

    교착 상태를 해결하기 위해서는 위의 조건 중 하나라도 성립하지 않도록 하면 됨

    ![pic](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/fbd42847-a1f9-4b3f-b4df-7f5f8f04859f/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20200905%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20200905T043320Z&X-Amz-Expires=86400&X-Amz-Signature=7c84fa937f9e110ec15e0f067cca87ba073d6373197cbc04adb7135a301511b2&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

    이건 그냥 어렵게 생각하지 말고, 4개의 조건이 있으며 A와 B가 자신의 자원을 차지중이고 서로의 자원까지 요구하는 그런 상황을 생각해보자

-
  - 메모리 계층을 설명해보세요
  - 레지스터, 캐시, 메모리, 하드디스크 순서로 계층이 이루어져 있음

-
  - 메모리 할당 알고리즘 중 First fit, Next fit, Best fit의 결과를 말해보세요
  - |
    * First fit: 메모리의 처음부터 탐색하며 크기가 충분한 공간이 있을 경우 할당
    * Next fit: 마지막으로 참조한 주소부터 탐색을 시작하며 크기가 충분한 공간이 있을 경우 할당
    * Best fit: 모든 메모리 공간을 검사하는것은 동일하나, 단편화를 최소화시킬 수 있는 공간에 할당하는 방식

-
  - 페이지 교체 알고리즘에 따른 Page Fault 방식을 설명해보세요
  - |
    # Page Fault가 무엇이냐

    프로세스가 어떤 특정 페이지를 요구하는 경우, 이를 메모리에서 가져와 사용해야 함

    이 때 필요로 하는 페이지가 메모리에 없는 경우를 Page Fault라고 하며, HDD와 같은 외부 저장 공간에서 페이지를 가져와

    메모리 내 빈 프레임이나 기존의 프레임을 교체하는 방식으로 메모리에 적재해 사용함

    다만... 빈 프레임은 그냥 적재하면 되는데, 기존의 프레임을 교체하는 경우에는 주의를 기울여야 함

    활발히 사용중인 페이지의 프레임을 교체해버린 경우에는 이를 다시 불러오기 위한 작업이 필요하기에 그만큼의 오버헤드가 발생되기 때문

    따라서 이를 위한 여러 알고리즘이 존재

    # Page Fault Algorithms

    ### FIFO (First In First Out)

    먼저 First In First Out 알고리즘이 있음

    가장 오래된 페이지를 교체하는 방식으로, 구현이 가장 간단하지만 상당히 비효율적인 알고리즘

    ### LRU (Last Recently Used)

    다음으로 가장 오래 사용되지 않은 페이지를 교체하는 알고리즘인 Last Recently Used 알고리즘이 있음

    교체 전까지 각 페이지가 참조되지 않은지 얼마나 지났는지를 확인하여 교체하는 방식으로

    상당히 효율적으로 동작하기에 여러 OS에서 채택하여 사용중

    ### LFU (Last Frequently Used)

    가장 적게 참조된 페이지를 교체하는 Last Frequently Used 알고리즘이란것도 있는데

    여기에는 약간의 이슈가 존재하여 잘 사용되지는 않음

    초반에 하나의 페이지를 집중적으로 사용하고, 이후 해당 페이지를 사용하지 않는다면

    교체되기 전까지 해당 프레임을 사용할 수 없게 된다는 이슈가 있기에 잘 사용되지는 않음

-
  - 가상 메모리가 무엇인가요
  - |
    물리적인 실제 메모리보다 더 많은 메모리를 필요로 하는 경우가 종종 있음

    이 경우 하드디스크와 같이 외부의 저장 공간을 이용하여 현재 메모리 내에서 사용되지 않는 데이터를 캐싱하는 방식으로

    마치 추가적인 메모리를 사용하는 것과 같이 동작하게 할 수 있는데

    이 때 이 외부의 저장 공간을 가상 메모리라고 함

-
  - 페이징과 프레임, 그리고 세그멘테이션이라는 단어를 들어보셨나요?
  - |
    # 페이징이란

    프로세스를 일정한 크기인 Page로 잘라 메모리에 적재하는 기법임

    page 단위로 프로세스를 잘라 관리하기에 단편화를 최대한 제거할 수 있음

    물론 마지막 page의 경우 약간의 내부 단편화가 발생하기는 하는데, 이는 기존 방법으로 인해 생겼던 외부 단편화보다는 매우 미미한 수준

    이는 메모리에서 가상 주소와 실제 주소를 매핑해주는 Memory Management Unit이라는 장치를 이용해 가능한데

    잘라진 page를 마치 연결된 것처럼 주소를 연결시켜서 CPU를 속이는 방식으로 페이징을 진행

    # 프레임

    페이징과 비슷한 기법인 프레임은, 프로세스가 아닌 메모리를 frame 단위로 잘라 관리하는 기법

    page와 frame을 같은 크기로 잘라 관리하게 되면 상당히 메모리 관리에 있어 편리하게 되겠지

    # 세그멘테이션

    세그멘테이션은 page와 비슷한데, page는 그냥 크기 단위로 프로세스를 잘랐지만 segment의 경우 논리적인 단위로 프로세스를 자르는 기법임

    가령... function은 function대로, class는 class대로 나누듯이 말이지

    이 덕분에 중요한 부분은 따로 관리할 수 있게 됨

    단, 크기는 동일하지 않기에 외부 단편화가 일어날 수 있음

    ## 세그먼트 페이징

    그래서 segment paging 이라는 기법을 이용하곤 하는데
    
    이건 논리적 단위로 자른 segment를 page 단위로 페이징하는 기법

    이 덕분에 세그멘테이션에서 나타났던 외부 단편화 문제를 해결할 수 있으나...

    물론 속도 측면에서는 좋지 못하다는게 단점

-
  - Mutex, Semaphore. 이 둘은 무엇이고, 둘의 차이점은?
  - |
    이 둘은 여러개의 프로세스나 스레드 사이에서 공유되는 자원에 대해 접근을 제한하기 위한 알고리즘

    # Semaphore

    먼저 Semaphore는 두 개 이상의 스레드나 프로세스에 대해 접근을 제한하는 알고리즘이며

    최대 수용치를 정해놓은 다음, 접근 시마다 하나씩 카운트를 줄여가는 방식으로 접근을 제한함

    # Mutex

    Mutex는 하나의 공유 자원에는 최대 하나의 프로세스나 스레드만이 접근할 수 있도록 상호배제적으로 접근을 제한하는 알고리즘

    이러한 특성으로 Semaphore는 Mutex로도 사용이 가능하지만, Mutex는 Semaphore로 사용이 불가능함

-
  - Context Switching은 무엇인가요
  - |
    concurrent system에서 주로 볼 수 있는 기법임

    프로세스에 대한 context switching을 예로 들어보자면

    CPU는 여러개의 프로세스가 잠깐잠깐씩 나누어서 사용해야 하는데

    이 때, 다른 프로세스로 switching하기 전에 현재 CPU를 사용하고 있는 프로세스의 정보를 Kernel의 Process Control Block이라는 자료구조로 저장하고

    그 이후에 다른 프로세스로 CPU 사용 권한을 넘기는 그런 작업이 바로 Context Switching임

    다시 원래 프로세스로 switching 할 때는 이 PCB에 기록된 정보를 이용해서 작업하게 됨

-
  - user level thread와 kernel level thread의 차이는 무엇인가?
  - |
    # user level thread

    먼저 user level thread의 경우

    라이브러리를 이용해 kernel level thread에서 fork되는 방식으로 만들어짐

    kernel level에서 구현된 것이 아니기에 스케줄링이나 동기화에 있어 library-level에서 관리가 가능하며, 이로 인한 오버헤드가 상대적으로 적다는 특징이 있음

    단, 마찬가지로 kernel level의 스레드가 아니기에 하나의 스레드가 정지된다면 다른 스레드 역시 영향을 받아 정지된다는 단점이 있음

    # kernel level thread

    다음으로 kernel level thread의 경우

    kernel에 요청해서 직접 스레드를 할당받아 사용하는 형태로 만들어지기에, 자원 면에서 있어 상대적으로 풍부하게 사용이 가능하고

    concurrent가 아닌 parallel 방식으로 스레드를 사용할 수가 있어 하나의 스레드가 멈추더라도 다른 스레드에는 영향을 끼치지 않는다는 특징이 있음

    다만, user level thread와는 달리 kernel level에서 thread context switching이 진행되기에, 이에 따른 system-call로 인한 오버헤드가 상대적으로 크다는 단점이 있음

-
  - Race Condition이란 무엇인가요
  - |
    두 개 이상의 프로세스가 공유 자원에 서로 접근하는 경우에 발생될 수 있음

    접근 순서에 따라 결과가 달라지는 것을 의미하는데

    다시말해 side-effects가 발생된다고 할 수 있겠으며

    이는 어떠한 동작에 대해 원하는 결과가 보장된다고 할 수 없기에

    mutex나 semaphore를 통해 적절한 제한을 취해주어야만 함

-
  - DBMS가 뭐죠?
  - |
    DataBase Management System의 약자로

    여러 사용자가 데이터베이스 내에서 원활하게 작업할 수 있도록 도와주는 시스템을 의미함

-
  - DB의 View는 무엇이고, 어디에 사용하나요
  - |
    허용된 데이터만을 제한적으로 보여주기 위해 하나 이상의 테이블에서 유도되어진 테이블

    이를 통해 보여주고 싶은 데이터만을 원본의 수정 없이 보여줄 수 있게 됨

-
  - DB 설계 시 가장 중요하다고 생각되는 부분은 무엇인가요
  - |
    데이터베이스를 설계할 때에는 무엇보다도 무결성이 가장 중요함

    * 모든 row가 서로 유일한 식별자로 갖고 있는가?
    * 외래키는 NULL 또는 외부 테이블의 Primary Key를 가리키고 있는가?
    * 모든 데이터는 범위 내의 적절한 값을 가지고 있는가?

    이러한 것들을 Create, Update, Delete 시 항상 검증해줘서 데이터베이스의 무결성을 유지해야만 함

    무결성이 훼손될 경우 데이터베이스 내 데이터의 정확성과 일관성이 떨어지기에 결국 실제 프로덕트에까지 큰 영향을 끼치게 됨

-
  - Commit과 Rollback은 무엇인가
  - |
    어떤 하나의 Transaction이 정상적으로 끝난 경우와 그렇지 않은 경우가 있음

    정상적으로 끝났을 때에는 그 작업이 정상적으로 끝났음을 확정시키기 위해 `commit`을 해야만 하고

    그렇지 않은 경우에는 그 작업을 적용하지 않기 위해 `rollback`을 해서 일관성이 깨지지 않은 이전 상태로 되돌려 놓아야만 함

-
  - OSI 7계층을 설명해보세요
  - |
    # OSI 7계층

    먼저 OSI 7계층이란

    네트워크 통신에 있어 사용 목적에 따라 7개의 layer로 분리한 국제 표준 통신 규약임

    물리, 데이터링크, 네트워크, 전송, 세션, 표현, 응용 7개의 layer가 존재하여 각각 다음과 같은 목적을 갖고 있음

    ### 물리 계층

    먼저 물리 계층은 실제 데이터가 전송되는 계층이며

    허브 같은 장비가 이 계층에 위치함

    ### 데이터링크

    다음으로 데이터링크 계층은 MAC을 이용해 데이터 송수신을 제어하는 계층으로써
    
    에러검출, 재전송, 흐름제어를 통해 송수신을 제어함

    
